// Verbindet sich mit dem SocketIO-Server
const socket = io();

// Globale Variablen zur Chart-Konfiguration und Logging
let chart;
let zoomLevel = 300;               // Anzahl der angezeigten Werte im Diagramm
let autoScroll = true;             // Automatischer Scroll im Diagramm
const maxDataPoints = 300;         // Maximale Datenpunkte im Chart
let logStartTime = null;           // Startzeitpunkt des Loggings
let logStartTimeWasSet = false;    // Ob Startzeitpunkt gesetzt wurde
let loggingActive = false;         // Ob Logging aktiv ist
let intervalHandle = null;         // Referenz auf Intervall zur Anzeige der Loggingdauer
let lastUpdateTime = 0;            // Zeitstempel der letzten Aktualisierung

// Anzeigeelement fÃ¼r die Dauer des Loggings
const durationEl = document.getElementById('logDuration');
if (durationEl) durationEl.innerText = "";

// Verbindung erfolgreich hergestellt
socket.on("connect", () => {
});

// EmpfÃ¤ngt Statusdaten vom Server und aktualisiert UI und Chart
socket.on("status_update", data => {
    const now = Date.now();
    if (now - lastUpdateTime >= 500) { // Aktualisierung nur alle 500ms
        lastUpdateTime = now;
        updateChart(data);

        // ðŸ”„ Werte aktualisieren (Temperatur, PWM, etc.)
        document.getElementById("timestampValue").textContent = data.timestamp ?? "--";
        document.getElementById("setpointValue").textContent = data.setpoint ?? "--";
        document.getElementById("inputValue").textContent = data.input ?? "--";
        document.getElementById("avgInputValue").textContent = data.avg_input ?? "--";
        document.getElementById("trendArrow").textContent = data.input_trend_arrow ?? "â†’";
        document.getElementById("pwmValue").textContent = data.pwm ?? "--";
        document.getElementById("flowrateValue").textContent = data.flowrate ?? "--";

        // PID-Platzhalter aktualisieren (zeigt aktuelle Werte)
        if (data.kp !== undefined) document.getElementById("kp").placeholder = data.kp;
        if (data.ki !== undefined) document.getElementById("ki").placeholder = data.ki;
        if (data.kd !== undefined) document.getElementById("kd").placeholder = data.kd;

        // Neue Zeile zur Logging-Tabelle hinzufÃ¼gen
        const table = document.getElementById("logTable");
        const row = document.createElement("tr");
        row.innerHTML = `
            <td>${data.timestamp}</td>
            <td>${data.setpoint}</td>
            <td>${data.input}</td>
            <td>${data.pwm}</td>
            <td>${data.flowrate}</td>
        `;
        table.prepend(row);
        while (table.children.length > 10) {
            table.removeChild(table.lastChild);
        }

        // Loggingstatus prÃ¼fen und ggf. umschalten
        if (data.hasOwnProperty("logging") && data.logging !== loggingActive) {
            loggingActive = data.logging;
            toggleLoggingStatus(data.logging);
        }

        // Startzeitpunkt setzen, falls noch nicht geschehen
        if (data.logging && data.log_start_time && !logStartTimeWasSet) {
            const cleanedStr = data.log_start_time.split(".")[0];
            logStartTime = new Date(cleanedStr);
            logStartTimeWasSet = true;

            if (!intervalHandle) {
                intervalHandle = setInterval(updateLogDuration, 1000);
            }
        }
    }
});

// Temperaturmessdaten fÃ¼r Min/Max/Ã˜ aktualisieren
socket.on("temperature_probe_update", data => {
    document.getElementById("probeMin").textContent = data.min;
    document.getElementById("probeMax").textContent = data.max;
    document.getElementById("probeAvg").textContent = data.avg;
    document.getElementById("probeCount").textContent = data.count;
});

// Statusmeldungen in die Statusanzeige schreiben
socket.on("status_message", data => {
    const logBox = document.getElementById("statusLog");
    const p = document.createElement("p");
    p.textContent = `${data.timestamp} â€“ ${data.message}`;
    logBox.prepend(p);
    while (logBox.children.length > 20) {
        logBox.removeChild(logBox.lastChild);
    }

    // Loggingstatus je nach Nachricht anpassen
    if (data.message.includes("Protokollierung gestartet")) {
        toggleLoggingStatus(true);
    } else if (data.message.includes("Protokollierung gestoppt")) {
        toggleLoggingStatus(false);
    }
});

// Aktualisiert das UI abhÃ¤ngig davon, ob Logging aktiv ist
function toggleLoggingStatus(active) {
    const box = document.getElementById("loggingStatusBox");
    const statusText = document.getElementById("loggingStatusText");
    const dot = box.querySelector(".status-dot");
    const startForm = document.getElementById("startLoggingForm");
    const stopForm = document.getElementById("stopLoggingForm");

    if (active) {
        box.classList.add("active-box");
        box.classList.remove("inactive-box");
        dot.classList.add("dot-green");
        dot.classList.remove("dot-gray");
        statusText.innerHTML = `Protokollierung aktiv â€“ seit <span id="logDuration">00:00:00</span>`;

        if (!logStartTime) {
            logStartTime = new Date();
        }

        if (!intervalHandle) {
            intervalHandle = setInterval(updateLogDuration, 1000);
        }

        if (startForm) startForm.style.display = "none";
        if (stopForm) stopForm.style.display = "block";
    } else {
        box.classList.remove("active-box");
        box.classList.add("inactive-box");
        dot.classList.remove("dot-green");
        dot.classList.add("dot-gray");
        statusText.innerHTML = `Protokollierung inaktiv`;

        if (startForm) startForm.style.display = "block";
        if (stopForm) stopForm.style.display = "none";

        logStartTime = null;
        logStartTimeWasSet = false;

        if (intervalHandle) {
            clearInterval(intervalHandle);
            intervalHandle = null;
        }
    }
}

// FÃ¼gt neue Werte in das Diagramm ein und aktualisiert die Anzeige
function updateChart(data) {
    if (!chart) return;

    const timeLabel = new Date().toLocaleTimeString();
    chart.data.labels.push(timeLabel);
    chart.data.datasets[0].data.push(parseFloat(data.setpoint));
    chart.data.datasets[1].data.push(parseFloat(data.input));
    chart.data.datasets[2].data.push(parseFloat(data.pwm));

    if (chart.data.labels.length > maxDataPoints) {
        chart.data.labels.shift();
        chart.data.datasets.forEach(ds => ds.data.shift());
    }

    if (autoScroll && zoomLevel > 0) {
        const totalPoints = chart.data.labels.length;
        if (totalPoints > zoomLevel) {
            chart.options.scales.x.min = totalPoints - zoomLevel;
            chart.options.scales.x.max = totalPoints;
        } else {
            chart.options.scales.x.min = undefined;
            chart.options.scales.x.max = undefined;
        }
    }

    chart.update('none'); // Keine Animation bei der Aktualisierung
}

// Initialisiert das Diagramm mit Konfigurationen
function setupChart() {
    const ctx = document.getElementById('dataChart').getContext('2d');
    chart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [
                { label: 'Sollwert', borderColor: 'blue', data: [], yAxisID: 'y', fill: false, pointRadius: 0 },
                { label: 'Istwert', borderColor: 'red', data: [], yAxisID: 'y', fill: false, pointRadius: 0 },
                { label: 'PWM', borderColor: 'orange', data: [], yAxisID: 'y1', fill: false, pointRadius: 0 }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: false,
            scales: {
                x: { title: { display: true, text: 'Uhrzeit' } },
                y: { title: { display: true, text: 'Temperatur [Â°C]' }, beginAtZero: false },
                y1: { title: { display: true, text: 'PWM [%]' }, position: 'right', min: 0, max: 100, grid: { drawOnChartArea: false } }
            }
        }
    });
}

// Berechnet und zeigt die vergangene Loggingdauer
function updateLogDuration() {
    if (!logStartTime) return;
    const seconds = Math.floor((Date.now() - logStartTime) / 1000);
    const h = String(Math.floor(seconds / 3600)).padStart(2, '0');
    const m = String(Math.floor((seconds % 3600) / 60)).padStart(2, '0');
    const s = String(seconds % 60).padStart(2, '0');
    document.getElementById('logDuration').innerText = `${h}:${m}:${s}`;
}

// Moduswechsel zwischen Automatik und Manuell
function changeMode() {
    const mode = document.getElementById('modeSelect').value;
    socket.emit('set_mode', {mode: mode});
    document.getElementById('manualControls').style.display = mode === 'manual' ? 'block' : 'none';
}

// Ã„ndert den Zoomfaktor fÃ¼r das Diagramm
function changeZoomLevel() {
    const select = document.getElementById('zoomSelect');
    zoomLevel = parseInt(select.value);
}

// Sendet manuell gesetzten PWM-Wert an den Server
function setManualPwm(event) {
    event.preventDefault();
    const pwm = event.target.manual_pwm.value;
    socket.emit('set_manual_pwm', {value: pwm});
}

// Sendet neuen Sollwert an den Server
function sendSetpoint(event) {
    event.preventDefault();
    const input = event.target.querySelector('input[name="setpoint"]');
    const value = parseFloat(input.value);
    if (!isNaN(value)) {
        socket.emit("send_setpoint", { value });
        input.value = "";
    } else {
        alert("UngÃ¼ltiger Sollwert.");
    }
}

// Sendet neue PID-Parameter an den Server
function sendPid(event) {
    event.preventDefault();
    const form = event.target;
    const kp = parseFloat(form.kp.value);
    const ki = parseFloat(form.ki.value);
    const kd = parseFloat(form.kd.value);
    if (!isNaN(kp) && !isNaN(ki) && !isNaN(kd)) {
        socket.emit("send_pid", { kp, ki, kd });
        form.reset();
    } else {
        alert("UngÃ¼ltige PID-Werte.");
    }
}

// Startet die Protokollierung mit einem gegebenen Namen
function startLogging(event) {
    event.preventDefault();
    const input = event.target.querySelector('input[name="log_name"]');
    const name = input.value.trim();
    if (name) {
        socket.emit("start_logging", { log_name: name });
        input.value = "";
    }
}

// Stoppt die laufende Protokollierung
function stopLogging(event) {
    event.preventDefault();
    socket.emit("stop_logging");
}

// Startet eine Temperaturmessung (Min, Max, Ã˜)
function startTempProbe() {
    socket.emit("start_temperature_probe");
    document.getElementById("probeMin").textContent = "--";
    document.getElementById("probeMax").textContent = "--";
    document.getElementById("probeAvg").textContent = "--";
    document.getElementById("probeCount").textContent = "0";
}

// Stoppt die Temperaturmessung
function stopTempProbe() {
    socket.emit("stop_temperature_probe");
}

// Sendet Neustartsignal an den Server (mit BestÃ¤tigung)
function confirmReboot() {
    if (confirm('Raspberry Pi wirklich neu starten?')) {
        socket.emit("reboot");
    }
}

// Initialisierung nach dem Laden des DOMs
document.addEventListener("DOMContentLoaded", () => {
    setupChart(); // Chart initialisieren

    const body = document.body;
    const loggingActive = body.dataset.logging === "true";
    const logStartStr = body.dataset.logstart;

    if (loggingActive && logStartStr) {
        const cleanedStr = logStartStr.split(".")[0];
        logStartTime = new Date(cleanedStr);
        logStartTimeWasSet = true;

        if (!isNaN(logStartTime)) {
            toggleLoggingStatus(true);
            if (!intervalHandle) {
                intervalHandle = setInterval(updateLogDuration, 1000);
            }
        }
    }

    socket.emit("request_status_log");

    const rebootButton = document.getElementById('rebootButton');
    if (rebootButton) {
        rebootButton.onclick = confirmReboot;
    }
});